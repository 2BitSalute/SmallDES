
namespace Mayak.ProbabilityDistributions.Discrete;

/// <summary>
/// Determines the probability that K events will occur in a particular
///     time interval, where K is >= 0.
///
/// Used to answer a question:
///     - How many events occur in a particular time interval?
///
/// In simulations, the Poisson distribution is useful for sampling potential
/// demands by customers for service, say, of cashiers, salesmen, etc.
///
/// The rate at which the service is provided often approximates a Poisson
/// probability law.
/// </summary>
/// <typeparam name="T"></typeparam>
public class PoissonProbabilityDistribution : DiscreteProbabilityDistribution<int>
{
    /// <summary>
    /// AKA `mu`
    /// </summary>
    private readonly double mean;

    /// <summary>
    /// The mean can also be called mu, but for Poisson, it is also the rate, which can be called lambda.
    /// </summary>
    /// <param name="mean">The average number (or rate) of events happening per unit interval</param>
    public PoissonProbabilityDistribution(double mean)
    {
        if (mean <= 0.0)
        {
            throw new ArgumentOutOfRangeException(nameof(mean), "Mean must be greater than 0.0");
        }

        this.mean = mean;
    }

    public override double Mean => this.mean;

    /// <summary>
    /// Because each event occurs independently, there is no added variability beyond
    /// the randomness already inherent in the average rate (mean)
    /// </summary>
    public override double Variance => this.mean;

    /// <summary>
    /// How many events occur in the next unit interval?
    /// </summary>
    /// <returns>The number of events</returns>
    public override IEnumerator<int> GetEnumerator()
    {
        // This is, again, a Knuth algorithm, though it is uncredited in the book
        while (true)
        {
            // the probability of zero events in a Poisson distribution
            var p = Math.Exp(-this.mean);

            // The count of events generated by the Poisson process (the result)
            var n = 0;

            // A product of uniform random numbers, which accumulates to compare against `p`
            var q = 1.0;

            while (true)
            {
                q *= q * Uniform.NextDouble();
                if (q < p)
                {
                    break;
                }

                n++;
            }

            yield return n;
        }
    }

    /// <summary>
    /// The probability of observing exactly x events in a unit interval
    /// </summary>
    /// <param name="x">The number of events</param>
    /// <returns>The probability.</returns>
    public override double Density(int x)
    {
        if (x < 0)
        {
            return 0.0;
        }

        return Math.Pow(this.mean, x) * Math.Exp(-this.mean) / MathFunctions.Factorial(x);
    }
}